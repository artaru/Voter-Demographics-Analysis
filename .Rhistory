palette="Reds",
sums_settings=sum_tile_settings(
label="Total",
palette="Greens"
))
###################
# STANDARDISE DATA
###################
# Convert the selected categorical variables to one-hot encoded vectors.
voter_data_sd <- dummy_cols(voter_data,
select_columns=categorical_variables,
# Remove first dummy variable to K-1 categories.
remove_first_dummy=TRUE,
remove_selected_columns=TRUE)
# Standardise numerical features to have a mean of 0 and standard deviation of 1
voter_data_sd <- voter_data_sd %>%
mutate(
age=(age - mean(age)) / sd(age),
interest_gen_1=(interest_gen_1 - mean(interest_gen_1)) / sd(interest_gen_1),
interest_elxn_1=(interest_elxn_1 - mean(interest_elxn_1)) / sd(interest_elxn_1),
groups_therm_1=(groups_therm_1 - mean(groups_therm_1)) / sd(groups_therm_1),
groups_therm_2=(groups_therm_2 - mean(groups_therm_2)) / sd(groups_therm_2),
groups_therm_3=(groups_therm_3 - mean(groups_therm_3)) / sd(groups_therm_3),
groups_therm_4=(groups_therm_4 - mean(groups_therm_4)) / sd(groups_therm_4),
groups_therm_5=(groups_therm_5 - mean(groups_therm_5)) / sd(groups_therm_5)
)
# Create training dataset
train_data_sd <- voter_data_sd %>% filter(rowid %in% training_indices)
# Create testing dataset (all observations NOT in the training data)
test_data_sd <- voter_data_sd %>% filter(!(rowid %in% training_indices))
# Optimal parameters found from svm_tune
# Note: we hardcoded this so that we don't have to re-run the svm tuning everytime.
BEST_SVM_GAMMA <- 0.01
BEST_SVM_COST <- 10
# Train the svm model
svm <- svm(votechoice ~ . - rowid,
data=train_data_sd,
method="C-classification",
kernal="radial",
gamma=BEST_SVM_GAMMA,
cost=BEST_SVM_COST)
svm_pred <- predict(svm, test_data_sd)
svm_confusion_matrix <- table("target"=test_data_sd$votechoice, "prediction"=svm_pred)
svm_accuracy <- accuracy(svm_confusion_matrix)
svm_accuracy
# confusionMatrix(svm_pred, test_data_sd$votechoice, mode="everything")
svm_cm_tidy <- tidy(svm_confusion_matrix) %>%
filter(target %in% c("Liberal Party", "Conservative Party") &
prediction %in% c("Liberal Party", "Conservative Party"))
plot_confusion_matrix(tree_cm_tidy,
target_col="target",
prediction_col="prediction",
counts_col="n",
add_sums=TRUE,
palette="Greens",
sums_settings=sum_tile_settings(
label="Total",
palette="Oranges"
))
# Remove rowid from the dataset (which was used for splitting the data for fitting the tree)
if ("rowid" %in% colnames(voter_data_sd)) {
voter_data_sd <- voter_data_sd %>% select(-rowid)
}
# Extract the labels from the voter_data_sd as a factor object
all_labels <- voter_data_sd$votechoice %>% as.factor() %>% unclass() - 1
# Remove the votechoice columns from
all_features <- voter_data_sd %>%
select(-votechoice) %>%
as.matrix()
# Create training dataset
# Make a smaller matrix consisting of the rows with ids given by training_indices
train_features <- all_features[training_indices,]
train_labels <- all_labels[training_indices]
# Create testing dataset (all observations NOT in the training data)
test_features <- all_features[-training_indices,]
test_labels <- all_labels[-training_indices]
votechoice_levels <- levels(all_labels)
levels(test_labels) <- votechoice_levels
# Load model from the saved checkpoint
model <- load_model_tf("checkpoint_nn_weights_binary")
# EVALUATION TIME!!!
test_score <- model %>% evaluate(test_features, test_labels, verbose=FALSE)
test_features
dim(test_features)
dim(test_labels)
test_labels
ggplot(data=ces19_liberal_data, aes(x=opinion)) +
geom_bar()
ggplot(data=ces19_liberal_data, aes(x=opinion)) +
geom_bar() +
ggtitle("Distribution of opinions (raw data)")
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar() +
ggtitle("Distribution of opinions (raw data)")
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar() +
ggtitle("Distribution of opinions (raw data)")
ggplot(data=ces19_liberal_data, aes(x=opinion)) +
geom_bar() +
ggtitle("Distribution of opinions (raw data)")
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar() +
ggtitle("Distribution of opinions (raw data)")
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar() +
ggtitle("Distribution of opinions (raw data)") +
theme_linedraw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar() +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="pink", border="black") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="black", fill="grey") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
# echo=FALSE will stop the code chunk from appearing in the knit document
# warning=FALSE and message=FALSE will stop R messages from appearing in the knit document
library(tidyverse)
library(broom)
library(rpart)
library(partykit)
# Confusion matrix functionality
library(caret)
library(cvms)
# For neural network functionality
library(keras)
library(reticulate)
# For creating dummy columns
library(fastDummies)
# For SVM (support vector machine) functionality
library("e1071")
# the data is not in the csv form we usually use, but in an R format, .rds.
# the following line saves it as ces19 and you can work with it as you're used to now
ces19 <- readRDS("ces19.rds")
set.seed(69)
# Filter ces19 data for observations where the votechoice variable is "Liberal Party" and add a "opinion" categorical variable indicating whether they support more ("Yes") or fewer refugees ("Yes"); neutral and ignored answers are not included.
ces19_liberal_data <- ces19 %>%
group_by(votechoice) %>%
# Filter out NA values for "refugees"
filter(votechoice == "Liberal Party" && !is.na(refugees)) %>%
mutate(opinion = case_when(
refugees == "More refugees" ~ "Yes",
refugees == "Fewer refugees" ~ "No")) %>%
# Filter out NA values for "opinion"
filter(!is.na(opinion))
# Compute the test statistic as the proportion of people whose opinion is "Yes".
q1_test_stat <- ces19_liberal_data %>%
summarise(n = n(), prop_yes = sum(opinion == "Yes") / n) %>%
summarise(value = prop_yes)
q1_test_stat <- as.numeric(q1_test_stat)
q1_test_stat
n_observations <- nrow(ces19_liberal_data) # number of observations
null_hypothesis <- 0.5 # equally likely to support more refugees or not.
q1_repetitions <- 10000
simulated_stats <- rep(NA, q1_repetitions) # 10000 missing values to start
# Run the simulation `q1_repetitions` times.
for (i in 1:q1_repetitions){
sim_result <- sample(c("Yes", "No"),
size=n_observations,
prob=c(null_hypothesis, 1 - null_hypothesis),
replace=TRUE)
p_yes <- sum(sim_result == "Yes") / n_observations
simulated_stats[i] <- p_yes; # add new value to vector of results
}
# Convert `simulated_stats` to tibble for plotting.
sim <- tibble(prop_yes = simulated_stats)
# Plot sampling distribution
distance_from_null_hypothesis = abs(null_hypothesis - q1_test_stat)
# sim %>% ggplot(aes(x = prop_yes)) +
#   geom_histogram(bins = 20, colour = "black", fill = "grey") +
#   geom_vline(xintercept=null_hypothesis + distance_from_null_hypothesis, colour="coral", size=1) +
#   geom_vline(xintercept=null_hypothesis - distance_from_null_hypothesis, colour="coral", size=1) +
#   theme_light() +
#   xlab("Proportion of people who support more refugees.") +
#   ggtitle("Estimated Sampling Distribution")
# compute p-value
pvalue <- sim %>%
filter(prop_yes >= null_hypothesis + distance_from_null_hypothesis |
prop_yes <= null_hypothesis - distance_from_null_hypothesis) %>%
summarise(p_value = n() / q1_repetitions)
as.numeric(pvalue)
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="pink", fill="grey") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="pink", fill="grey") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="grey", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="grey", fill="yellow", linewidth=2) +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="grey", fill="pink", linewidth=2) +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="grey", fill="pink", lwd=2) +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="orange", fill="pink", lwd=2) +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="orange", fill="pink", lwd=1) +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="grey", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="grey", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="grey", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="pink", fill="grey") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="pink", fill="black") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="black", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw()
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="black", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw(plot.title=element_text(size=20, face="bold"))
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="black", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=20, face="bold"))
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="black", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=6, face="bold"))
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="black", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=12, face="bold"))
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="black", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=8, face="bold"))
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="black", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=8, face="bold")) +
xlabel("Opinion") +
ylabel("Count")
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="black", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=8, face="bold")) +
labs(x="Opinion", y="Number of Responses"))
ggplot(data=ces19_liberal_data, aes(x=refugees)) +
geom_bar(color="black", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=8, face="bold")) +
labs(x="Opinion", y="Number of Responses")
# Simple function to calculate accuracy given a confusion matrix
accuracy <- function(confusion_matrix) {
return(sum(diag(confusion_matrix)) / sum(confusion_matrix))
}
tree_pred <- predict(tree, newdata=test_data, type="class")
# Calculate the CONFUSION MATRIX (I'M SO CONFUSED!)
tree_confusion_matrix <- table("target"=test_data$votechoice, "prediction"=tree_pred)
# Calculate accuracy
tree_accuracy <- accuracy(tree_confusion_matrix)
tree_accuracy
tree_cm_tidy <- tidy(tree_confusion_matrix) %>%
filter(target %in% c("Liberal Party", "Conservative Party") &
prediction %in% c("Liberal Party", "Conservative Party"))
# confusionMatrix(tree_pred, test_data$votechoice, mode="everything")
plot_confusion_matrix(tree_cm_tidy,
target_col="target",
prediction_col="prediction",
counts_col="n",
add_sums=TRUE,
palette="Reds",
sums_settings=sum_tile_settings(
label="Total",
palette="Greens"
))
# echo=FALSE will stop the code chunk from appearing in the knit document
# warning=FALSE and message=FALSE will stop R messages from appearing in the knit document
library(tidyverse)
library(broom)
library(rpart)
library(partykit)
# Confusion matrix functionality
library(caret)
library(cvms)
library(ggnewscale)
# For neural network functionality
library(keras)
library(reticulate)
# For creating dummy columns
library(fastDummies)
# For SVM (support vector machine) functionality
library("e1071")
# the data is not in the csv form we usually use, but in an R format, .rds.
# the following line saves it as ces19 and you can work with it as you're used to now
ces19 <- readRDS("ces19.rds")
set.seed(69)
# Simple function to calculate accuracy given a confusion matrix
accuracy <- function(confusion_matrix) {
return(sum(diag(confusion_matrix)) / sum(confusion_matrix))
}
tree_pred <- predict(tree, newdata=test_data, type="class")
# Calculate the CONFUSION MATRIX (I'M SO CONFUSED!)
tree_confusion_matrix <- table("target"=test_data$votechoice, "prediction"=tree_pred)
# Calculate accuracy
tree_accuracy <- accuracy(tree_confusion_matrix)
tree_accuracy
tree_cm_tidy <- tidy(tree_confusion_matrix) %>%
filter(target %in% c("Liberal Party", "Conservative Party") &
prediction %in% c("Liberal Party", "Conservative Party"))
# confusionMatrix(tree_pred, test_data$votechoice, mode="everything")
plot_confusion_matrix(tree_cm_tidy,
target_col="target",
prediction_col="prediction",
counts_col="n",
add_sums=TRUE,
palette="Reds",
sums_settings=sum_tile_settings(
label="Total",
palette="Greens"
))
# Simple function to calculate accuracy given a confusion matrix
accuracy <- function(confusion_matrix) {
return(sum(diag(confusion_matrix)) / sum(confusion_matrix))
}
tree_pred <- predict(tree, newdata=test_data, type="class")
# Calculate the CONFUSION MATRIX (I'M SO CONFUSED!)
tree_confusion_matrix <- table("target"=test_data$votechoice, "prediction"=tree_pred)
# Calculate accuracy
tree_accuracy <- accuracy(tree_confusion_matrix)
tree_accuracy
tree_cm_tidy <- tidy(tree_confusion_matrix) %>%
filter(target %in% c("Liberal Party", "Conservative Party") &
prediction %in% c("Liberal Party", "Conservative Party"))
# confusionMatrix(tree_pred, test_data$votechoice, mode="everything")
plot_confusion_matrix(tree_cm_tidy,
target_col="target",
prediction_col="prediction",
counts_col="n",
add_sums=TRUE,
palette="Reds",
sums_settings=sum_tile_settings(
label="Total",
palette="Oranges"
))
svm_pred <- predict(svm, test_data_sd)
svm_confusion_matrix <- table("target"=test_data_sd$votechoice, "prediction"=svm_pred)
svm_accuracy <- accuracy(svm_confusion_matrix)
svm_accuracy
# confusionMatrix(svm_pred, test_data_sd$votechoice, mode="everything")
svm_cm_tidy <- tidy(svm_confusion_matrix) %>%
filter(target %in% c("Liberal Party", "Conservative Party") &
prediction %in% c("Liberal Party", "Conservative Party"))
plot_confusion_matrix(tree_cm_tidy,
target_col="target",
prediction_col="prediction",
counts_col="n",
add_sums=TRUE,
palette="Greens",
sums_settings=sum_tile_settings(
label="Total",
palette="Oranges"
))
svm_pred <- predict(svm, test_data_sd)
svm_confusion_matrix <- table("target"=test_data_sd$votechoice, "prediction"=svm_pred)
svm_accuracy <- accuracy(svm_confusion_matrix)
svm_accuracy
# confusionMatrix(svm_pred, test_data_sd$votechoice, mode="everything")
svm_cm_tidy <- tidy(svm_confusion_matrix) %>%
filter(target %in% c("Liberal Party", "Conservative Party") &
prediction %in% c("Liberal Party", "Conservative Party"))
plot_confusion_matrix(tree_cm_tidy,
target_col="target",
prediction_col="prediction",
counts_col="n",
add_sums=TRUE,
palette="Blues",
sums_settings=sum_tile_settings(
label="Total",
palette="Greens"
))
svm_pred <- predict(svm, test_data_sd)
svm_confusion_matrix <- table("target"=test_data_sd$votechoice, "prediction"=svm_pred)
svm_accuracy <- accuracy(svm_confusion_matrix)
svm_accuracy
# confusionMatrix(svm_pred, test_data_sd$votechoice, mode="everything")
svm_cm_tidy <- tidy(svm_confusion_matrix) %>%
filter(target %in% c("Liberal Party", "Conservative Party") &
prediction %in% c("Liberal Party", "Conservative Party"))
plot_confusion_matrix(tree_cm_tidy,
target_col="target",
prediction_col="prediction",
counts_col="n",
add_sums=TRUE,
palette="Blues",
sums_settings=sum_tile_settings(
label="Total",
palette="Greens"
))
ces19 %>% group_by(gender) %>%
summarise(count=n(), prop=count / nrow(ces19_men_women))
ggplot(aes(y=lead_rating_23, x=gender), data=ces19_men_women) +
geom_boxplot(color="black", fill="gray")
ces19 %>% group_by(gender) %>%
summarise(count=n(), prop=count / nrow(ces19_men_women))
ggplot(aes(y=lead_rating_23, x=gender), data=ces19_men_women) +
geom_boxplot(color="black", fill="gray")
# Suppress summarise info
options(dplyr.summarise.inform = FALSE)
test_stat <- ces19_men_women %>%
group_by(gender) %>%
summarise(medians = median(lead_rating_23)) %>%
summarise(value = diff(medians))
test_stat <- as.numeric(test_stat)
test_stat
q2_repetitions <- 1000;
simulated_values <- rep(NA, q2_repetitions)
for(i in 1:q2_repetitions){
simdata <- ces19_men_women %>% mutate(gender = sample(gender))
sim_value <- simdata %>% group_by(gender) %>%
summarise(medians = median(lead_rating_23)) %>%
summarise(value = diff(medians))
simulated_values[i] <- as.numeric(sim_value)
}
sim <- tibble(median_diff = simulated_values)
# sim %>% ggplot(aes(x=median_diff)) + geom_histogram(bins=10, color="black", fill="gray")
# Calculate p-value
num_more_extreme <- sim %>% filter(abs(median_diff) >= abs(test_stat)) %>% summarise(n())
p_value <- as.numeric(num_more_extreme / q2_repetitions)
p_value
ces19 %>% group_by(gender) %>%
summarise(count=n(), prop=count / nrow(ces19_men_women))
ggplot(aes(y=lead_rating_23, x=gender), data=ces19_men_women) +
geom_boxplot(color="black", fill="pink") +
ggtitle("Distribution of opinions (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=8, face="bold")) +
labs(x="Opinion", y="Number of Responses")
ces19 %>% group_by(gender) %>%
summarise(count=n(), prop=count / nrow(ces19_men_women))
ggplot(aes(y=lead_rating_23, x=gender), data=ces19_men_women) +
geom_boxplot(color="black", fill="pink") +
ggtitle("Distribution of ratings for men and women (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=8, face="bold")) +
labs(x="Opinion", y="Number of Responses")
ces19 %>% group_by(gender) %>%
summarise(count=n(), prop=count / nrow(ces19_men_women))
ggplot(aes(y=lead_rating_23, x=gender), data=ces19_men_women) +
geom_boxplot(color="black", fill="pink") +
ggtitle("Distribution of ratings (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=8, face="bold")) +
labs(x="Opinion", y="Number of Responses")
ces19 %>% group_by(gender) %>%
summarise(count=n(), prop=count / nrow(ces19_men_women))
ggplot(aes(y=lead_rating_23, x=gender), data=ces19_men_women) +
geom_boxplot(color="black", fill="pink") +
ggtitle("Distribution of ratings (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=8, face="bold")) +
labs(x="Gender")
ces19 %>% group_by(gender) %>%
summarise(count=n(), prop=count / nrow(ces19_men_women))
ggplot(aes(y=lead_rating_23, x=gender), data=ces19_men_women) +
geom_boxplot(color="black", fill="pink") +
ggtitle("Distribution of ratings (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=8, face="bold")) +
labs(x="Gender", y="Rating of Justin Trudeau (0-100)")
ces19 %>% group_by(gender) %>%
summarise(count=n(), prop=count / nrow(ces19_men_women))
ggplot(aes(y=lead_rating_23, x=gender), data=ces19_men_women) +
geom_boxplot(color="black", fill="pink") +
ggtitle("Distribution of ratings (raw data)") +
theme_bw() +
theme(plot.title=element_text(size=8, face="bold")) +
labs(x="Gender", y="Rating of Trudeau (0-100)")
# Download scheer.png
download.file("https://i.imgur.com/FmykiVq.png","scheer.png", mode="wb")
